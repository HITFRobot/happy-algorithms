---
layout: post
title: 字符串最小编辑距离
categories: algorithm
description: 
keywords: nlp, dp
---

# 最小编辑距离

在自然语言处理中，有一个需要解决的问题就是求解两个字符串的最小编辑距离，我们先看一眼对于编辑距离的定义:

>For two stings X of length n, Y of length m, we define D(i,j) :
>
>- i.e., the first i characters of X and the first j characters of Y
>- The edit distance between X and Y is thus D(n,m)
>
>The minimum edit distance between two strings is the minimum number of editing operations(Insertion, Deletion, Substitution) needed to transform one into the other.

例如，我们现在有字符串`X = Hello` 和字符串`Y = How`，我们有三种操作可以执行，使得一个字符串转化为另一个字符串，删除，插入，替换。对于上面的例子，我们可以执行如下操作，`1. e替换为o 2. l替换为w 3. 插入l 4. 插入o`，如果每个操作的权值我们都定义为1，上面X和Y的编辑距离就是4。当然，将X变换为Y的方式不止一种，我们想通过算法来求解最小的编辑距离，下面介绍动态规划算法来求解该问题。

## 动态规划求解最小编辑距离

在求解动态规划问题的时候，都需要回答以下几个问题:

- **状态是什么**❓ 在最小编辑距离中，我们定义`D[i][j]`为长度为`i`的字符串X和长度为`j`的字符串Y的最小编辑距离，我们要求解的就是最终的状态`D[m][n]`
- **初始状态值是多少**❓有了状态的定义，我们就可以找出初始状态的值，因为在动态规划中，我们要做的是求解最终的状态， 这必须依赖于初始状态和转移方程。一般来说，初始状态都是边界值，就是`D[i][0]`和`D[0][j]`。在最小编辑距离问题中，`D[i][0]`表示长度为i的字符串和长度为0的字符串的最小编辑距离，显然只能通过添加操作，得到长度为i的字符串，所以有`D[i][0]=i`。同理`D[0][j]=j`
- **转移方程**❓转移方程是动态规划中的重点，这个方程应具体问题具体分析，在本问题中，看下面示意图:

![](http://upload-images.jianshu.io/upload_images/9371887-43b34db08c2b1729.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

这里我用 `# I N T E N T I O N` 表示字符串X，`# E X E C U T I O N`表示字符串Y。假设现在要计算的是`D[i][j]，此时i指向T,j指向E`，我们要定义转移方程，也就是如何用已知的状态来推出现在的状态，换句话说，就是将当前状态`D[i][j]`用之前状态来求解。

那么怎么表示呢？虽然这个方程需要具体问题具体分析得到，但是分析的过程一般是一样的，如何做分析呢？

1. **数型结合**，可以先画出示意图，方便我们分析，如上面我画的这个示意图；

2. **转化化归**，要知道，我们是想通过用已知来表示未知，所以在示意图画出来后，我们要明白要做的是将未知的`D[i][j]`转化为前面已知状态表示。

3. **分类整合**,这里实际上有两个小步骤:

   - **分类**:用已知表示未知，或者从已知走向未知，路径往往不唯一！可以说在动态规划问题里肯定是不唯一的，也就是说`D[i][j]`可以有多条路径得到。这时候我们就要**分类讨论**，在这个问题中，我在示意图画出了三种颜色的线，分别表示三种不同的路径:

     - 红色: `D[i][j]`可以这样得到，先用X(1..i)表示Y(1...j-1)，此时应该求他们的最小编辑距离`D[i][j-1]`，然后呢插入Y(j)，所以，最后总的编辑距离为

       `D[i][j] = D[i][j-1] + 1 (insert)`

     - 蓝色:  `D[i][j]`可以这样得到，先用X(1..i-1)表示Y(1…j)，此时应该求他们的最小编辑距离`D[i-1][j]`，删除X(i)，所以，最后总的编辑距离为

       `D[i][j] = D[i-1][j] + 1 (delete)`

     - 黄色:  `D[i][j]`可以这样得到，先用长度为j-1的字符串表示长度为i-1的字符串，此时应该求他们的最小编辑距离`D[i-1][j-1]`，然后呢做一下判断X(i)是否等于Y(j)，如果相等就不要做替换操作，否则需要做替换操作，所以，最后总的编辑距离为

       `D[i][j] = D[i-1][j-1] + 0 if X(i) = Y(j)`

       `D[i][j] = D[i-1][j-1] + 2 if X(i) != Y(j) 注意，替换操作编辑距离为2`

   - **整合**: 这一步就是对上述所有路径求最小值(或者最大值)

所有最后的转移方程如下:

![](https://latex.codecogs.com/gif.latex?D%5Bi%5D%5Bj%5D%20%3D%20min%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%20D%28i-1%2Cj%29%20&plus;%201%5C%5C%20D%28i%2C%20j-1%29%20&plus;%201%5C%5C%20D%28i-1%2C%20j-1%29%20&plus;%200%20%28X%28i%29%20%3D%3D%20Y%28j%29%29%20or%20D%28i-1%2Cj-1%29%20&plus;%202%28X%28i%29%20%21%3D%20Y%28j%29%29%20%5Cend%7Bmatrix%7D%5Cright.)

最后，得到的dp表如下:

![](http://upload-images.jianshu.io/upload_images/9371887-2f1a041d196bc4be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

添加Backtrace来记录如何转化的:

![](http://upload-images.jianshu.io/upload_images/9371887-2f696b140d9ce014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

### 时间、空间复杂度

时间复杂度: $O(nm)$

空间复杂度: $O(nm)$

Backtrace : $O(n+m)$

### 带权编辑距离

带权编辑距离只是将delete insert subtitude 三个操作用一个权值函数表示，整个动态规划的过程并没有改变。

